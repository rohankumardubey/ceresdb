<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CeresDB Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">Introduction</li><li class="chapter-item "><a href="about.html"><strong aria-hidden="true">1.</strong> What is CeresDB</a></li><li class="chapter-item "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item affix "><li class="part-title">User Guide</li><li class="chapter-item "><a href="sql/index.html"><strong aria-hidden="true">3.</strong> SQL Syntax</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sql/model/index.html"><strong aria-hidden="true">3.1.</strong> Data Model</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sql/model/data_types.html"><strong aria-hidden="true">3.1.1.</strong> Data Types</a></li><li class="chapter-item "><a href="sql/model/special_columns.html"><strong aria-hidden="true">3.1.2.</strong> Special Columns</a></li></ol></li><li class="chapter-item "><a href="sql/identifier.html"><strong aria-hidden="true">3.2.</strong> Identifier</a></li><li class="chapter-item "><a href="sql/ddl/index.html"><strong aria-hidden="true">3.3.</strong> Data Definition Statements</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sql/ddl/create_table.html"><strong aria-hidden="true">3.3.1.</strong> CREATE TABLE</a></li><li class="chapter-item "><a href="sql/ddl/alter_table.html"><strong aria-hidden="true">3.3.2.</strong> ALTER TABLE</a></li></ol></li><li class="chapter-item "><a href="sql/dml/index.html"><strong aria-hidden="true">3.4.</strong> Data Manipulation Statements</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sql/dml/insert.html"><strong aria-hidden="true">3.4.1.</strong> INSERT</a></li><li class="chapter-item "><a href="sql/dml/select.html"><strong aria-hidden="true">3.4.2.</strong> SELECT</a></li></ol></li><li class="chapter-item "><a href="sql/utility.html"><strong aria-hidden="true">3.5.</strong> Utility Statements</a></li><li class="chapter-item "><a href="sql/engine_options.html"><strong aria-hidden="true">3.6.</strong> Engine Options</a></li></ol></li><li class="chapter-item "><a href="deploy/index.html"><strong aria-hidden="true">4.</strong> Deployment</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="deploy/platform.html"><strong aria-hidden="true">4.1.</strong> Supported Platform</a></li><li class="chapter-item "><a href="deploy/static_routing.html"><strong aria-hidden="true">4.2.</strong> Static Routing</a></li><li class="chapter-item "><a href="deploy/dynamic_routing.html"><strong aria-hidden="true">4.3.</strong> Dynamic Routing</a></li></ol></li><li class="chapter-item "><a href="sdk.html"><strong aria-hidden="true">5.</strong> Develop Kits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/java.html"><strong aria-hidden="true">5.1.</strong> Java SDK</a></li><li class="chapter-item "><a href="sdk/go.html"><strong aria-hidden="true">5.2.</strong> Go SDK</a></li><li class="chapter-item "><a href="sdk/python.html"><strong aria-hidden="true">5.3.</strong> Python SDK</a></li><li class="chapter-item "><a href="sdk/rust.html"><strong aria-hidden="true">5.4.</strong> Rust SDK</a></li></ol></li><li class="chapter-item "><a href="operation/index.html"><strong aria-hidden="true">6.</strong> Operation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="operation/table.html"><strong aria-hidden="true">6.1.</strong> Table</a></li><li class="chapter-item "><a href="operation/system_table.html"><strong aria-hidden="true">6.2.</strong> System Table</a></li><li class="chapter-item "><a href="operation/block_list.html"><strong aria-hidden="true">6.3.</strong> Block List</a></li><li class="chapter-item "><a href="operation/observability.html"><strong aria-hidden="true">6.4.</strong> Observability</a></li></ol></li><li class="chapter-item "><li class="part-title">Dev Guide</li><li class="chapter-item "><a href="dev/platform.html"><strong aria-hidden="true">7.</strong> Supported Platform</a></li><li class="chapter-item "><a href="dev/compile_run.html"><strong aria-hidden="true">8.</strong> Compile and Running</a></li><li class="chapter-item "><a href="dev/conventional_commit.html"><strong aria-hidden="true">9.</strong> Conventional Commit</a></li><li class="chapter-item "><a href="dev/style_guide.html"><strong aria-hidden="true">10.</strong> Style guide</a></li><li class="chapter-item "><a href="dev/roadmap.html"><strong aria-hidden="true">11.</strong> Roadmap</a></li><li class="chapter-item affix "><li class="part-title">Technical and Design</li><li class="chapter-item "><a href="architecture.html"><strong aria-hidden="true">12.</strong> Architecture</a></li><li class="chapter-item "><a href="storage.html"><strong aria-hidden="true">13.</strong> Storage</a></li><li class="chapter-item "><a href="query.html"><strong aria-hidden="true">14.</strong> Query</a></li><li class="chapter-item "><a href="wal.html"><strong aria-hidden="true">15.</strong> Wal</a></li><li class="chapter-item "><a href="table_partitioning.html"><strong aria-hidden="true">16.</strong> Table Partitioning</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CeresDB Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="https://github.com/CeresDB/ceresdb/raw/main/docs/logo/CeresDB.png" alt="CeresDB" /></p>
<p><img src="https://img.shields.io/badge/license-Apache--2.0-green.svg" alt="License" />
<a href="https://github.com/CeresDB/ceresdb/actions/workflows/ci.yml"><img src="https://github.com/CeresDB/ceresdb/actions/workflows/ci.yml/badge.svg" alt="CI" /></a>
<a href="https://github.com/CeresDB/ceresdb/issues"><img src="https://img.shields.io/github/issues/CeresDB/ceresdb" alt="OpenIssue" /></a>
<a href="https://join.slack.com/t/ceresdbcommunity/shared_invite/zt-1dcbv8yq8-Fv8aVUb6ODTL7kxbzs9fnA"><img src="https://badgen.net/badge/Slack/Join%20CeresDB/0abd59?icon=slack" alt="Slack" /></a>
<a href="https://hub.docker.com/r/ceresdb/ceresdb-server"><img src="https://img.shields.io/docker/v/ceresdb/ceresdb-server?logo=docker" alt="Docker" /></a></p>
<p>CeresDB is a timeseries database that aims to handle both timeseries and analytic workloads efficiently.</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>In the traditional timeseries database, the <code>Tag</code> columns (InfluxDB calls them <code>Tag</code> and Prometheus calls them <code>Label</code>) are normally indexed by generating an inverted index. However, it is found that the cardinality of <code>Tag</code> varies in different scenarios. And in some scenarios the cardinality of <code>Tag</code> is very high, and it takes a very high cost to store and retrieve the inverted index. On the other hand, it is observed that scanning+pruning often used by the analytical databases can do a good job to handle such these scenarios.</p>
<p>The basic design idea of CeresDB is to adopt a hybrid storage format and the corresponding query method for a better performance in processing both timeseries and analytic workloads.</p>
<h1 id="how-does-ceresdb-work"><a class="header" href="#how-does-ceresdb-work">How does CeresDB work?</a></h1>
<ul>
<li>See <a href="quick_start.html">Quick Start</a> to learn about how to get started</li>
<li>For data model of CeresDB, see <a href="sql/model">Data Model</a></li>
<li>For the supported SQL data types, operators, and commands, please navigate to <a href="sql">SQL reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>This page shows you how to get started with CeresDB quickly. You'll start a standalone CeresDB server, and then insert and read some sample data using SQL.</p>
<h2 id="start-server"><a class="header" href="#start-server">Start server</a></h2>
<p><a href="https://hub.docker.com/r/ceresdb/ceresdb-server">CeresDB docker image</a> is the easiest way to get started, if you haven't installed Docker, go <a href="https://www.docker.com/products/docker-desktop/">there</a> to install it first.</p>
<p>You can use command below to start a standalone server</p>
<pre><code class="language-bash">docker run -d --name ceresdb-server \
  -p 8831:8831 \
  -p 3307:3307 \
  -p 5440:5440 \
  ceresdb/ceresdb-server:v0.3.1
</code></pre>
<p>CeresDB will listen three ports when start:</p>
<ul>
<li>8831, gRPC port</li>
<li>3307, MySQL port</li>
<li>5440, HTTP port</li>
</ul>
<p>The easiest to use is HTTP, so sections below will use it for demo. For production environments, gRPC/MySQL are recommended.</p>
<h2 id="write-and-read-data"><a class="header" href="#write-and-read-data">Write and read data</a></h2>
<h3 id="create-table"><a class="header" href="#create-table">Create table</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--data-raw '
CREATE TABLE `demo` (
    `name` string TAG,
    `value` double NOT NULL,
    `t` timestamp NOT NULL,
    timestamp KEY (t))
ENGINE=Analytic
  with
(enable_ttl=&quot;false&quot;)
'
</code></pre>
<h3 id="write-data"><a class="header" href="#write-data">Write data</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--data-raw '
INSERT INTO demo (t, name, value)
    VALUES (1651737067000, &quot;ceresdb&quot;, 100)
'
</code></pre>
<h3 id="read-data"><a class="header" href="#read-data">Read data</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--data-raw '
SELECT
    *
FROM
    `demo`
'
</code></pre>
<h3 id="show-create-table"><a class="header" href="#show-create-table">Show create table</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--data-raw '
SHOW CREATE TABLE `demo`
'
</code></pre>
<h3 id="drop-table"><a class="header" href="#drop-table">Drop table</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--data-raw '
DROP TABLE `demo`
'
</code></pre>
<h2 id="using-the-sdks"><a class="header" href="#using-the-sdks">Using the SDKs</a></h2>
<p>See <a href="./sdk.html">sdk</a></p>
<h2 id="next-step"><a class="header" href="#next-step">Next Step</a></h2>
<p>Congrats, you have finished this tutorial. For more information about CeresDB, see the following:</p>
<ul>
<li><a href="sql/model">Data Model</a></li>
<li><a href="./analytic_engine">Analytic Engine</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-syntax"><a class="header" href="#sql-syntax">SQL Syntax</a></h1>
<p>This chapter introduces the SQL interface of CeresDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-model"><a class="header" href="#data-model">Data Model</a></h1>
<p>This chapter introduces the data model of CeresDB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>CeresDB implements table model, and the supported data types are similar to MySQL.
The following table lists the mapping relationship between MySQL and CeresDB.</p>
<h2 id="support-data-typecase-insensitive"><a class="header" href="#support-data-typecase-insensitive">Support Data Type(case-insensitive)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>SQL</th><th>CeresDB</th></tr></thead><tbody>
<tr><td>null</td><td>Null</td></tr>
<tr><td>timestamp</td><td>Timestamp</td></tr>
<tr><td>double</td><td>Double</td></tr>
<tr><td>float</td><td>Float</td></tr>
<tr><td>string</td><td>String</td></tr>
<tr><td>Varbinary</td><td>Varbinary</td></tr>
<tr><td>uint64</td><td>UInt64</td></tr>
<tr><td>uint32</td><td>UInt32</td></tr>
<tr><td>uint16</td><td>UInt16</td></tr>
<tr><td>uint8</td><td>UInt8</td></tr>
<tr><td>int64/bigint</td><td>Int64</td></tr>
<tr><td>int32/int</td><td>Int32</td></tr>
<tr><td>int16/smallint</td><td>Int16</td></tr>
<tr><td>int8/tinyint</td><td>Int8</td></tr>
<tr><td>boolean</td><td>Boolean</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="special-columns"><a class="header" href="#special-columns">Special Columns</a></h1>
<p>Tables in CeresDB have the following constraints:</p>
<ul>
<li>Primary key is required</li>
<li>The primary key must contain a time column, and can only contain one time column</li>
<li>The primary key must be non-null, so all columns in primary key must be non-null.</li>
</ul>
<h2 id="timestamp-column"><a class="header" href="#timestamp-column">Timestamp Column</a></h2>
<p>Tables in CeresDB must have one timestamp column maps to timestamp in timeseries data, such as timestamp in OpenTSDB/Prometheus.
The timestamp column can be set with <code>timestamp key</code> keyword, like <code>TIMESTAMP KEY(ts)</code>.</p>
<h2 id="tag-column"><a class="header" href="#tag-column">Tag column</a></h2>
<p><code>Tag</code> is use to defined column as tag column, similar to tag in timeseries data, such as tag in OpenTSDB and label in Prometheus.</p>
<h2 id="primary-key"><a class="header" href="#primary-key">Primary key</a></h2>
<p>The primary key is used for data deduplication and sorting. The primary key is composed of some columns and one time column.
The primary key can be set in the following some ways：</p>
<ul>
<li>use <code>primary key</code> keyword</li>
<li>use <code>tag</code> to auto generate TSID, CeresDB will use <code>(timestamp,TSID)</code> as primary key</li>
<li>only set Timestamp column, CeresDB will use <code>(timestamp)</code> as primary key</li>
</ul>
<p>Notice: If the primary key and tag are specified at the same time, then the tag column is just an additional information identification and will not affect the logic.</p>
<pre><code class="language-sql">CREATE TABLE with_primary_key(
  ts TIMESTAMP NOT NULL,
  c1 STRING NOT NULL,
  c2 STRING NULL,
  c4 STRING NULL,
  c5 STRING NULL,
  TIMESTAMP KEY(ts),
  PRIMARY KEY(c1, ts)
) ENGINE=Analytic WITH (ttl='7d');
  
CREATE TABLE with_tag(
    ts TIMESTAMP NOT NULL,
    c1 STRING TAG NOT NULL,
    c2 STRING TAG NULL,
    c3 STRING TAG NULL,
    c4 DOUBLE NULL,
    c5 STRING NULL,
    c6 STRING NULL,
    TIMESTAMP KEY(ts)
) ENGINE=Analytic WITH (ttl='7d');

CREATE TABLE with_timestamp(
    ts TIMESTAMP NOT NULL,
    c1 STRING NOT NULL,
    c2 STRING NULL,
    c3 STRING NULL,
    c4 DOUBLE NULL,
    c5 STRING NULL,
    c6 STRING NULL,
    TIMESTAMP KEY(ts)
) ENGINE=Analytic WITH (ttl='7d');
</code></pre>
<h2 id="tsid"><a class="header" href="#tsid">TSID</a></h2>
<p>If <code>primary key</code>is not set, and tag columns is provided, TSID will auto generated from hash of tag columns. 
In essence, this is also a mechanism for automatically generating id.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifier"><a class="header" href="#identifier">Identifier</a></h1>
<p>Identifier in CeresDB can be used as table name, column name etc. It cannot be preserved keywords or start with number and punctuation symbols. CeresDB allows to quote identifiers with back quotes (`). In this case it can be any string like <code>00_table</code> or <code>select</code>.</p>
<p>Note: it's required to wrap column or table name in back quotes to keep them case-sensitive, such as</p>
<pre><code class="language-sql">show create table `demo`;
show create table `DEMO`;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-definition-statements"><a class="header" href="#data-definition-statements">Data Definition Statements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-table-1"><a class="header" href="#create-table-1">CREATE TABLE</a></h1>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic syntax</a></h2>
<p>Basic syntax (parts between <code>[]</code> are optional):</p>
<pre><code class="language-sql">CREATE TABLE [IF NOT EXIST] 
    table_name ( column_definitions ) 
    ENGINE = engine_type 
    [WITH ( table_options )];
</code></pre>
<p>Column definition syntax:</p>
<pre><code class="language-sql">column_name column_type [[NOT] NULL] {[TAG] | [TIMESTAMP KEY] | [PRIMARY KEY]}
</code></pre>
<p>Table options syntax are key-value pairs. Value should be quote with quotation marks (<code>'</code>). E.g.:</p>
<pre><code class="language-sql">... WITH ( enable_ttl='false' )
</code></pre>
<h2 id="if-not-exist"><a class="header" href="#if-not-exist">IF NOT EXIST</a></h2>
<p>Add <code>IF NOT EXIST</code> to tell CeresDB to ignore errors if the table name already exists.</p>
<h2 id="define-column"><a class="header" href="#define-column">Define Column</a></h2>
<p>A column's definition should at least contains the name and type parts. All supported types are listed <a href="sql/ddl/../model/data_types.html">here</a>.</p>
<p>Column is default be nullable. i.e. <code>NULL</code> keyword is implied. Adding <code>NOT NULL</code> constrains to make it required.</p>
<pre><code class="language-sql">-- this definition
a_nullable int
-- equals to
a_nullable int NULL

-- add NOT NULL to make it required
b_not_null NOT NULL
</code></pre>
<p>A column can be marked as <a href="sql/ddl/../model/special_columns.html">special column</a> with related keyword.</p>
<h2 id="engine"><a class="header" href="#engine">Engine</a></h2>
<p>Specifies which engine this table belongs to. CeresDB current support <a href="sql/ddl/../../analytic_engine/README.html"><code>Analytic</code></a> engine type. This attribute is immutable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alter-table"><a class="header" href="#alter-table">ALTER TABLE</a></h1>
<p><code>ALTER TABLE</code> can change the schema or options of a table.</p>
<p>CeresDB current supports <code>ADD COLUMN</code>.</p>
<pre><code class="language-sql">-- create a table and add a column to it
CREATE TABLE `t`(a int, t timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE = Analytic;
ALTER TABLE `t` ADD COLUMN (b string);
</code></pre>
<p>It now becomes</p>
<pre><code>-- DESCRIBE TABLE `t`;

name    type        is_primary  is_nullable is_tag

t       timestamp   true        false       false
tsid    uint64      true        false       false
a       int         false       true        false
b       string      false       true        false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-manipulation-statements"><a class="header" href="#data-manipulation-statements">Data Manipulation Statements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="insert"><a class="header" href="#insert">INSERT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">SELECT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utility-statements"><a class="header" href="#utility-statements">Utility Statements</a></h1>
<p>There are serval utilities SQL in CeresDB that can help in table manipulation or query inspection.</p>
<h2 id="show-create-table-1"><a class="header" href="#show-create-table-1">SHOW CREATE TABLE</a></h2>
<pre><code class="language-sql">SHOW CREATE TABLE table_name;
</code></pre>
<p><code>SHOW CREATE TABLE</code> returns a <code>CREATE TABLE</code> DDL that will create a same table with the given one. Including columns, table engine and options. The schema and options shows in <code>CREATE TABLE</code> will based on the current version of the table. An example:</p>
<pre><code class="language-sql">-- create one table
CREATE TABLE `t` (a bigint, b int default 3, c string default 'x', d smallint null, t timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE = Analytic;
-- Result: affected_rows: 0

-- show how one table should be created.
SHOW CREATE TABLE `t`;

-- Result DDL:
CREATE TABLE `t` (
    `t` timestamp NOT NULL,
    `tsid` uint64 NOT NULL,
    `a` bigint,
    `b` int,
    `c` string,
    `d` smallint,
    PRIMARY KEY(t,tsid),
    TIMESTAMP KEY(t)
) ENGINE=Analytic WITH (
    arena_block_size='2097152',
    compaction_strategy='default',
    compression='ZSTD',
    enable_ttl='true',
    num_rows_per_row_group='8192',
    segment_duration='',
    ttl='7d',
    update_mode='OVERWRITE',
    write_buffer_size='33554432'
)
</code></pre>
<h2 id="describe"><a class="header" href="#describe">DESCRIBE</a></h2>
<pre><code class="language-sql">DESCRIBE table_name;
</code></pre>
<p><code>DESCRIBE</code> will show a detailed schema of one table. The attributes include column name and type, whether it is tag and primary key (todo: ref) and whether it's nullable. The auto created column <code>tsid</code> will also be included (todo: ref).</p>
<p>Example:</p>
<pre><code class="language-sql">CREATE TABLE `t`(a int, b string, t timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE = Analytic;

DESCRIBE TABLE `t`;
</code></pre>
<p>The result is:</p>
<pre><code>name    type        is_primary  is_nullable is_tag

t       timestamp   true        false       false
tsid    uint64      true        false       false
a       int         false       true        false
b       string      false       true        false
</code></pre>
<h2 id="explain"><a class="header" href="#explain">EXPLAIN</a></h2>
<pre><code class="language-sql">EXPLAIN query;
</code></pre>
<p><code>EXPLAIN</code> shows how a query will be executed. Add it to the beginning of a query like</p>
<pre><code class="language-sql">EXPLAIN SELECT max(value) AS c1, avg(value) AS c2 FROM `t` GROUP BY name;
</code></pre>
<p>will give</p>
<pre><code>logical_plan
Projection: #MAX(07_optimizer_t.value) AS c1, #AVG(07_optimizer_t.value) AS c2
  Aggregate: groupBy=[[#07_optimizer_t.name]], aggr=[[MAX(#07_optimizer_t.value), AVG(#07_optimizer_t.value)]]
    TableScan: 07_optimizer_t projection=Some([name, value])

physical_plan
ProjectionExec: expr=[MAX(07_optimizer_t.value)@1 as c1, AVG(07_optimizer_t.value)@2 as c2]
  AggregateExec: mode=FinalPartitioned, gby=[name@0 as name], aggr=[MAX(07_optimizer_t.value), AVG(07_optimizer_t.value)]
    CoalesceBatchesExec: target_batch_size=4096
      RepartitionExec: partitioning=Hash([Column { name: \&quot;name\&quot;, index: 0 }], 6)
        AggregateExec: mode=Partial, gby=[name@0 as name], aggr=[MAX(07_optimizer_t.value), AVG(07_optimizer_t.value)]
          ScanTable: table=07_optimizer_t, parallelism=8, order=None
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>Options below can be used when create table for analytic engine</p>
<ul>
<li>
<p><code>enable_ttl</code>, <code>bool</code>. When enable TTL on a table, rows older than <code>ttl</code> will be deleted and can't be querid, default <code>true</code></p>
</li>
<li>
<p><code>ttl</code>, <code>duration</code>, lifetime of a row, only used when <code>enable_ttl</code> is <code>true</code>. default <code>7d</code>.</p>
</li>
<li>
<p><code>storage_format</code>, <code>string</code>. The underlying column's format. Availiable values:</p>
<ul>
<li><code>columnar</code>, default</li>
<li><code>hybrid</code></li>
</ul>
<p>The meaning of those two values are in <a href="sql/engine_options.html#storage-format">Storage format</a> section.</p>
</li>
</ul>
<h2 id="storage-format"><a class="header" href="#storage-format">Storage Format</a></h2>
<p>There are mainly two formats supported in analytic engine. One is <code>columnar</code>, which is the traditional columnar format, with one table column in one physical column:</p>
<pre><code class="language-plaintext">| Timestamp | Device ID | Status Code | Tag 1 | Tag 2 |
| --------- |---------- | ----------- | ----- | ----- |
| 12:01     | A         | 0           | v1    | v1    |
| 12:01     | B         | 0           | v2    | v2    |
| 12:02     | A         | 0           | v1    | v1    |
| 12:02     | B         | 1           | v2    | v2    |
| 12:03     | A         | 0           | v1    | v1    |
| 12:03     | B         | 0           | v2    | v2    |
| .....     |           |             |       |       |
</code></pre>
<p>The other one is <code>hybrid</code>, an experimental format used to simulate row-oriented storage in columnar storage to accelerate traditional time-series query.</p>
<p>In traditional time-series user cases like IoT or DevOps, queries will typically first group their result by series id(or device id), then by timestamp. In order to achieve good performance in those scenarios, the data physical layout should match this style, so the <code>hybrid</code> format is proposed like this:</p>
<pre><code class="language-plaintext"> | Device ID | Timestamp           | Status Code | Tag 1 | Tag 2 | minTime | maxTime |
 |-----------|---------------------|-------------|-------|-------|---------|---------|
 | A         | [12:01,12:02,12:03] | [0,0,0]     | v1    | v1    | 12:01   | 12:03   |
 | B         | [12:01,12:02,12:03] | [0,1,0]     | v2    | v2    | 12:01   | 12:03   |
 | ...       |                     |             |       |       |         |         |
</code></pre>
<ul>
<li>Within one file, rows belonging to the same primary key(eg: series/device id) are collapsed into one row</li>
<li>The columns besides primary key are divided into two categories:
<ul>
<li><code>collapsible</code>, those columns will be collapsed into a list. Used to encode <code>fields</code> in time-series table
<ul>
<li>Note: only fixed-length type is supported now</li>
</ul>
</li>
<li><code>non-collapsible</code>, those columns should only contain one distinct value. Used to encode <code>tags</code> in time-series table
<ul>
<li>Note: only string type is supported now</li>
</ul>
</li>
</ul>
</li>
<li>Two more columns are added, <code>minTime</code> and <code>maxTime</code>. Those are used to cut unnecessary rows out in query.
<ul>
<li>Note: Not implemented yet.</li>
</ul>
</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-sql">CREATE TABLE `device` (
    `ts` timestamp NOT NULL,
    `tag1` string tag,
    `tag2` string tag,
    `value1` double,
    `value2` int,
    timestamp KEY (ts)) ENGINE=Analytic
  with (
    enable_ttl = 'false',
    storage_format = 'hybrid'
);
</code></pre>
<p>This will create a table with hybrid format, users can inspect data format with <a href="https://formulae.brew.sh/formula/parquet-tools">parquet-tools</a>. The table above should have following parquet schema:</p>
<pre><code>message arrow_schema {
  optional group ts (LIST) {
    repeated group list {
      optional int64 item (TIMESTAMP(MILLIS,false));
    }
  }
  required int64 tsid (INTEGER(64,false));
  optional binary tag1 (STRING);
  optional binary tag2 (STRING);
  optional group value1 (LIST) {
    repeated group list {
      optional double item;
    }
  }
  optional group value2 (LIST) {
    repeated group list {
      optional int32 item;
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>CeresDB is a distributed timeseries database, that is to say, multiple CeresDB instances can be deployed as a cluster to serve with high availability and scalability.</p>
<p>For now, CeresDB only supports one deployment form that features static, rule-based routing. In the future (maybe in 1.0.0 version), a powerful cluster deployment will be supported and then CeresDB cluster will support more great features, including dynamic expansion, data reliability and etc.</p>
<div style="break-before: page; page-break-before: always;"></div><p>As an open source cloud-native, CeresDB can be deployed in the Intel/ARM-based architecture server, and major virtualization environments.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">OS</th><th style="text-align: center">status</th></tr></thead><tbody>
<tr><td style="text-align: center">Ubuntu LTS 16.06 or later</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">CentOS 7.3 or later</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">Red Hat Enterprise Linux 7.3 or later 7.x releases</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">macOS 11 or later</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">Windows</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div>
<ul>
<li>For production workloads, Linux is the preferred platform.</li>
<li>macOS is mainly used for development</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-routing"><a class="header" href="#static-routing">Static Routing</a></h1>
<p>This guide shows how to deploy a CeresDB cluster with static, rule-based routing.</p>
<p>The crucial point here is that CeresDB server provides configurable routing function on table name so what we need is just a valid config containing routing rules which will be shipped to every CeresDB instance in the cluster.</p>
<h2 id="target"><a class="header" href="#target">Target</a></h2>
<p>First, let's assume that our target is to deploy a cluster consisting of two CeresDB instances on the same machine. And a large cluster of more CeresDB instances can deploy according to the two-instances example.</p>
<h2 id="prepare-config"><a class="header" href="#prepare-config">Prepare Config</a></h2>
<h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<p>Suppose the basic config of CeresDB is:</p>
<pre><code class="language-toml">bind_addr = &quot;0.0.0.0&quot;
http_port = 5440
grpc_port = 8831
log_level = &quot;info&quot;
enable_cluster = true

[analytic]
wal_path = &quot;/tmp/ceresdb&quot;

[analytic.storage]
type = &quot;Local&quot;
data_path = &quot;/tmp/ceresdb&quot;
</code></pre>
<p>In order to deploy two CeresDB instances on the same machine, the config should choose different ports to serve and data directories to store data.</p>
<p>Say the <code>CeresDB_0</code>'s config is:</p>
<pre><code class="language-toml">bind_addr = &quot;0.0.0.0&quot;
http_port = 5440
grpc_port = 8831
log_level = &quot;info&quot;
enable_cluster = true

[analytic]
wal_path = &quot;/tmp/ceresdb_0&quot;

[analytic.storage]
type = &quot;Local&quot;
data_path = &quot;/tmp/ceresdb_0&quot;
</code></pre>
<p>Then the <code>CeresDB_1</code>'s config is:</p>
<pre><code class="language-toml">bind_addr = &quot;0.0.0.0&quot;
http_port = 15440
grpc_port = 18831
log_level = &quot;info&quot;
enable_cluster = true

[analytic]
wal_path = &quot;/tmp/ceresdb_1&quot;

[analytic.storage]
type = &quot;Local&quot;
data_path = &quot;/tmp/ceresdb_1&quot;
</code></pre>
<h3 id="schemashard-declaration"><a class="header" href="#schemashard-declaration">Schema&amp;Shard declaration</a></h3>
<p>Then we should define the common part -- schema&amp;shard declaration and routing rules.</p>
<p>Here is the config for schema&amp;shard declaration:</p>
<pre><code class="language-toml">[[static_route.topology.schema_shards]]
schema = 'public_0'
[[static_route.topology.schema_shards.shard_views]]
shard_id = 0
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[static_route.topology.schema_shards.shard_views]]
shard_id = 1
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831

[[static_route.topology.schema_shards]]
schema = 'public_1'
[[static_route.topology.schema_shards.shard_views]]
shard_id = 0
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[static_route.topology.schema_shards.shard_views]]
shard_id = 1
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 18831
</code></pre>
<p>In the config above, two schemas are declared:</p>
<ul>
<li><code>public_0</code> has two shards served by <code>CeresDB_0</code>.</li>
<li><code>public_1</code> has two shards served by both <code>CeresDB_0</code> and <code>CeresDB_1</code>.</li>
</ul>
<h3 id="routing-rules"><a class="header" href="#routing-rules">Routing rules</a></h3>
<p>Provided with shcema&amp;shard declaration, routing rules can be defined and here is an example of prefix rule:</p>
<pre><code class="language-toml">[[route_rules.prefix_rules]]
schema = 'public_0'
prefix = 'prod_'
shard = 0
</code></pre>
<p>This rule means that all the table with <code>prod_</code> prefix belonging to <code>public_0</code> should be routed to <code>shard_0</code> of <code>public_0</code>, that is to say, <code>CeresDB_0</code>. As for the other tables whose names are not prefixed by <code>prod_</code> will be routed by hash to both <code>shard_0</code> and <code>shard_1</code> of <code>public_0</code>.</p>
<p>Besides prefix rule, we can also define a hash rule:</p>
<pre><code class="language-toml">[[route_rules.hash_rules]]
schema = 'public_1'
shards = [0, 1]
</code></pre>
<p>This rule tells CeresDB to route <code>public_1</code>'s tables to both <code>shard_0</code> and <code>shard_1</code> of <code>public_1</code>, that is to say, <code>CeresDB0</code> and <code>CeresDB_1</code>. And actually this is default routing behavior if no such rule provided for schema <code>public_1</code>.</p>
<p>For now, we can provide the full example config for <code>CeresDB_0</code> and <code>CeresDB_1</code>:</p>
<pre><code class="language-toml">bind_addr = &quot;0.0.0.0&quot;
http_port = 5440
grpc_port = 8831
log_level = &quot;info&quot;
enable_cluster = true

[analytic]
wal_path = &quot;/tmp/ceresdb_0&quot;

[analytic.storage]
type = &quot;Local&quot;
data_path = &quot;/tmp/ceresdb_0&quot;

[[static_route.topology.schema_shards]]
schema = 'public_0'
[[static_route.topology.schema_shards.shard_views]]
shard_id = 0
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[static_route.topology.schema_shards.shard_views]]
shard_id = 1
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831

[[static_route.topology.schema_shards]]
schema = 'public_1'
[[static_route.topology.schema_shards.shard_views]]
shard_id = 0
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[static_route.topology.schema_shards.shard_views]]
shard_id = 1
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 18831

[[static_route.rules.prefix_rules]]
schema = 'public_0'
prefix = 'prod_'
shard = 0

[[static_route.rules.hash_rules]]
schema = 'public_1'
shards = [0, 1]
</code></pre>
<pre><code class="language-toml">bind_addr = &quot;0.0.0.0&quot;
http_port = 15440
grpc_port = 18831
log_level = &quot;info&quot;
enable_cluster = true

[analytic]
wal_path = &quot;/tmp/ceresdb_1&quot;

[analytic.storage]
type = &quot;Local&quot;
data_path = &quot;/tmp/ceresdb_1&quot;

[[static_route.topology.schema_shards]]
schema = 'public_0'
[[static_route.topology.schema_shards.shard_views]]
shard_id = 0
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[static_route.topology.schema_shards.shard_views]]
shard_id = 1
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831

[[static_route.topology.schema_shards]]
schema = 'public_1'
[[static_route.topology.schema_shards.shard_views]]
shard_id = 0
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 8831
[[static_route.topology.schema_shards.shard_views]]
shard_id = 1
[static_route.topology.schema_shards.shard_views.endpoint]
addr = '127.0.0.1'
port = 18831

[[static_route.rules.prefix_rules]]
schema = 'public_0'
prefix = 'prod_'
shard = 0

[[static_route.rules.hash_rules]]
schema = 'public_1'
shards = [0, 1]
</code></pre>
<p>Let's call the two different config files as <code>config_0.toml</code> and <code>config_1.toml</code> but you should know in the real environment the different CeresDB intances can be deployed across different machines, that is to say, there is no need to choose different ports and data directories for different CeresDB instances so that all the CeresDB instances can share one exactly <strong>same</strong> config file.</p>
<h2 id="start-ceresdbs"><a class="header" href="#start-ceresdbs">Start CeresDBs</a></h2>
<p>After the configs are prepared, what we should to do is to start CeresDB container with the specific config.</p>
<p>Just run the commands below:</p>
<pre><code class="language-shell">sudo docker run -d -t --name ceresdb_0 -p 5440:5440 -p 8831:8831 -v $(pwd)/config_0.toml:/etc/ceresdb/ceresdb.toml ceresdb/ceresdb-server:v0.1.0-alpha
sudo docker run -d -t --name ceresdb_1 -p 15440:15440 -p 18831:18831 -v $(pwd)/config_1.toml:/etc/ceresdb/ceresdb.toml ceresdb/ceresdb-server:v0.1.0-alpha
</code></pre>
<p>After the two containers are created and starting running, read and write requests can be served by the two-instances CeresDB cluster. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-routing"><a class="header" href="#dynamic-routing">Dynamic Routing</a></h1>
<p>This guide shows how to deploy a CeresDB cluster with CeresMeta.</p>
<h2 id="target-1"><a class="header" href="#target-1">Target</a></h2>
<p>First, let's assume that our target is to deploy a cluster consisting of two CeresDB instances on the same machine. And a large cluster of more CeresDB instances can deploy according to the two-instances example.</p>
<h2 id="start-ceresdbs-1"><a class="header" href="#start-ceresdbs-1">Start CeresDBs</a></h2>
<p>You can use the following command to create a CeresDB cluster with two instances.</p>
<ol>
<li>
<p>Start CeresMeta first
Refer to <a href="https://github.com/CeresDB/ceresmeta">CeresMeta</a></p>
</li>
<li>
<p>Prepare config of CeresDB</p>
</li>
</ol>
<pre><code class="language-toml"># {project_path}/docs/example-cluster-0.toml
bind_addr = &quot;0.0.0.0&quot;
http_port = 5440
grpc_port = 8831
mysql_port = 3307
log_level = &quot;info&quot;
deploy_mode = &quot;Cluster&quot;

[analytic]
wal_path = &quot;/tmp/ceresdb0&quot;

[analytic.storage]
mem_cache_capacity = '1G'
mem_cache_partition_bits = 0

[analytic.storage.object_store]
type = &quot;Local&quot;
data_path = &quot;/tmp/ceresdb0&quot;

[cluster]
cmd_channel_buffer_size = 10

[cluster.node]
addr = &quot;127.0.0.1&quot;
port = 8831

[cluster.meta_client]
# Only support &quot;defaultCluster&quot; currently.
cluster_name = &quot;defaultCluster&quot;
meta_addr = &quot;http://127.0.0.1:2379&quot;
lease = &quot;10s&quot;
timeout = &quot;5s&quot;

[limiter]
write_block_list = ['mytable1']
read_block_list = ['mytable1']
</code></pre>
<pre><code class="language-toml"># {project_path}/docs/example-cluster-1.toml
bind_addr = &quot;0.0.0.0&quot;
http_port = 5441
grpc_port = 8832
mysql_port = 13307
log_level = &quot;info&quot;
deploy_mode = &quot;Cluster&quot;

[analytic]
wal_path = &quot;/tmp/ceresdb1&quot;

[analytic.storage]
mem_cache_capacity = '1G'
mem_cache_partition_bits = 0

[analytic.storage.object_store]
type = &quot;Local&quot;
data_path = &quot;/tmp/ceresdb1&quot;

[cluster]
cmd_channel_buffer_size = 10

[cluster.node]
addr = &quot;127.0.0.1&quot;
port = 8832

[cluster.meta_client]
# Only support &quot;defaultCluster&quot; currently.
cluster_name = &quot;defaultCluster&quot;
meta_addr = &quot;http://127.0.0.1:2379&quot;
lease = &quot;10s&quot;
timeout = &quot;5s&quot;

[limiter]
write_block_list = ['mytable1']
read_block_list = ['mytable1']
</code></pre>
<ol start="3">
<li>Start CeresDB instances</li>
</ol>
<ul>
<li>You need to replace <code>{project_path}</code> with the actual project path</li>
</ul>
<pre><code class="language-bash"># Update address of CeresMeta in CeresDB config.
docker run -d --name ceresdb-server \
  -p 8831:8831 \
  -p 3307:3307 \
  -p 5440:5440 \
  -v {project_path}/docs/example-cluster-0.toml:/etc/ceresdb/ceresdb.toml \
  ceresdb/ceresdb-server:v0.3.1
  
docker run -d --name ceresdb-server2 \
  -p 8832:8832 \
  -p 13307:13307 \
  -p 5441:5441 \
  -v {project_path}/docs/example-cluster-1.toml:/etc/ceresdb/ceresdb.toml \
  ceresdb/ceresdb-server:v0.3.1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-kits"><a class="header" href="#develop-kits">Develop Kits</a></h1>
<ul>
<li><a href="https://github.com/CeresDB/ceresdb-client-rs">Rust</a></li>
<li><a href="https://github.com/CeresDB/ceresdb-client-java">Java</a></li>
<li><a href="https://github.com/CeresDB/ceresdb-client-py">Python</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">Java</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operation-and-maintenance"><a class="header" href="#operation-and-maintenance">Operation and Maintenance</a></h1>
<p>This guide introduces the operation and maintenance of CeresDB, including cluster installation, database&amp;table operations, fault tolerance, disaster recovery, data import and export, etc.</p>
<ul>
<li><a href="operation/./table.html">Table</a> </li>
<li><a href="operation/./system_table.html">System Table</a> </li>
<li><a href="operation/./block_list.html">Block List</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-operation"><a class="header" href="#table-operation">Table Operation</a></h1>
<p>CeresDB supports standard SQL protocols and allows you to create tables and read/write data via http requests.</p>
<h2 id="create-table-2"><a class="header" href="#create-table-2">Create Table</a></h2>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;query&quot;: &quot;CREATE TABLE `demo` (`name` string TAG, `value` double NOT NULL, `t` timestamp NOT NULL, TIMESTAMP KEY(t)) ENGINE=Analytic with (enable_ttl='\''false'\'')&quot;
}'
</code></pre>
<h2 id="write-data-1"><a class="header" href="#write-data-1">Write Data</a></h2>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;query&quot;: &quot;INSERT INTO demo(t, name, value) VALUES(1651737067000, '\''ceresdb'\'', 100)&quot;
}'
</code></pre>
<h2 id="read-data-1"><a class="header" href="#read-data-1">Read Data</a></h2>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;query&quot;: &quot;select * from demo&quot;
}'
</code></pre>
<h2 id="query-table-info"><a class="header" href="#query-table-info">Query Table Info</a></h2>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;query&quot;: &quot;show create table demo&quot;
}'
</code></pre>
<h3 id="drop-table-1"><a class="header" href="#drop-table-1">Drop Table</a></h3>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://127.0.0.1:5440/sql' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;query&quot;: &quot;DROP TABLE demo&quot;
}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-operation-1"><a class="header" href="#table-operation-1">Table Operation</a></h1>
<h2 id="query-table-information"><a class="header" href="#query-table-information">Query Table Information</a></h2>
<p>Like Mysql's <code>information_schema.tables</code>, CeresDB provides <code>system.public.tables</code> to save tables information.
Columns:</p>
<ul>
<li>timestamp([TimeStamp])</li>
<li>catalog([String])</li>
<li>schema([String])</li>
<li>table_name([String])</li>
<li>table_id([Uint64])</li>
<li>engine([String])</li>
</ul>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<p>Query table information via table_name like this:</p>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:5000/sql' \
--header 'Content-Type: application/json' \
--header 'x-ceresdb-access-schema: my_schema' \
-d '{
    &quot;query&quot;: &quot;select * from system.public.tables where `table_name`=\&quot;my_table\&quot;&quot;
}'
</code></pre>
<h3 id="response"><a class="header" href="#response">Response</a></h3>
<pre><code class="language-json">{
    &quot;rows&quot;:[
        {
            &quot;timestamp&quot;:0,
            &quot;catalog&quot;:&quot;ceresdb&quot;,
            &quot;schema&quot;:&quot;monitor_trace&quot;,
            &quot;table_name&quot;:&quot;my_table&quot;,
            &quot;table_id&quot;:3298534886446,
            &quot;engine&quot;:&quot;Analytic&quot;
        }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-list"><a class="header" href="#block-list">Block List</a></h1>
<h2 id="add-block-list"><a class="header" href="#add-block-list">Add block list</a></h2>
<p>If you want to reject query for a table, you can add table name to 'read_block_list'.</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:5000/block' \
--header 'Content-Type: application/json' \
-d '{
    &quot;operation&quot;:&quot;Add&quot;,
    &quot;write_block_list&quot;:[],
    &quot;read_block_list&quot;:[&quot;my_table&quot;]
}'
</code></pre>
<h3 id="response-1"><a class="header" href="#response-1">Response</a></h3>
<pre><code class="language-json">{
  &quot;write_block_list&quot;:[

  ],
  &quot;read_block_list&quot;:[
    &quot;my_table&quot;
  ]
}
</code></pre>
<h2 id="set-block-list"><a class="header" href="#set-block-list">Set block list</a></h2>
<p>You can use set operation to clear exist tables and set new tables to 'read_block_list' like following example.</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:5000/block' \
--header 'Content-Type: application/json' \
-d '{
    &quot;operation&quot;:&quot;Set&quot;,
    &quot;write_block_list&quot;:[],
    &quot;read_block_list&quot;:[&quot;my_table1&quot;,&quot;my_table2&quot;]
}'
</code></pre>
<h3 id="response-2"><a class="header" href="#response-2">Response</a></h3>
<pre><code class="language-json">{
  &quot;write_block_list&quot;:[

  ],
  &quot;read_block_list&quot;:[
    &quot;my_table1&quot;,
    &quot;my_table2&quot;
  ]
}
</code></pre>
<h2 id="remove-block-list"><a class="header" href="#remove-block-list">Remove block list</a></h2>
<p>You can remove tables from  'read_block_list' like following example.</p>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:5000/block' \
--header 'Content-Type: application/json' \
-d '{
    &quot;operation&quot;:&quot;Remove&quot;,
    &quot;write_block_list&quot;:[],
    &quot;read_block_list&quot;:[&quot;my_table1&quot;]
}'
</code></pre>
<h3 id="response-3"><a class="header" href="#response-3">Response</a></h3>
<pre><code class="language-json">{
  &quot;write_block_list&quot;:[

  ],
  &quot;read_block_list&quot;:[
    &quot;my_table2&quot;
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observability"><a class="header" href="#observability">Observability</a></h1>
<p>CeresDB is observable with Prometheus and Grafana.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">target</th><th style="text-align: center">OS</th><th style="text-align: center">status</th></tr></thead><tbody>
<tr><td style="text-align: center">x86_64-unknown-linux-gnu</td><td style="text-align: center">kernel 4.9+</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">x86_64-apple-darwin</td><td style="text-align: center">10.15+, Catalina+</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">aarch64-apple-darwin</td><td style="text-align: center">11+, Big Sur+</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">aarch64-unknown-linux-gnu</td><td style="text-align: center">TBD</td><td style="text-align: center">tracked on <a href="https://github.com/CeresDB/ceresdb/issues/63">#63</a></td></tr>
<tr><td style="text-align: center">*-windows</td><td style="text-align: center">*</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><p>In order to compile CeresDB, some relevant dependencies(including the <code>Rust</code> toolchain) should be installed.</p>
<h1 id="dependenciesubuntu2004"><a class="header" href="#dependenciesubuntu2004">Dependencies(Ubuntu20.04)</a></h1>
<p>Assuming the development environment is Ubuntu20.04, execute the following command to install the required dependencies:</p>
<pre><code class="language-shell">apt install git curl gcc g++ libssl-dev pkg-config cmake
</code></pre>
<p>It should be noted that the compilation of the project has version requirements for dependencies such as cmake, gcc, g++, etc. If your development environment is an old Linux distribution, it is necessary to manually install these dependencies of a higher version.</p>
<h1 id="dependenciesmacos"><a class="header" href="#dependenciesmacos">Dependencies(MacOS)</a></h1>
<p>If the development environment is MacOS, execute the following command to install the required dependencies.</p>
<ol>
<li>Install command line tools:</li>
</ol>
<pre><code class="language-shell">xcode-select --install
</code></pre>
<ol start="2">
<li>Install cmake:</li>
</ol>
<pre><code class="language-shell">brew install cmake
</code></pre>
<ol start="3">
<li>Install protobuf:</li>
</ol>
<pre><code class="language-shell">brew install protobuf
</code></pre>
<h1 id="rust-1"><a class="header" href="#rust-1">Rust</a></h1>
<p><code>Rust</code> can be installed by <a href="https://rustup.rs/">rustup</a>. After installing rustup, when entering the CeresDB project, the specified <code>Rust</code> version will be automatically downloaded according to the rust-toolchain file.</p>
<p>After execution, you need to add environment variables to use the <code>Rust</code> toolchain. Basically, just put the following commands into your <code>~/.bashrc</code> or <code>~/.bash_profile</code>:</p>
<pre><code class="language-shell">source $HOME/.cargo/env
</code></pre>
<h1 id="compile-and-run"><a class="header" href="#compile-and-run">Compile and run</a></h1>
<p>Compile CeresDB by the following command:</p>
<pre><code>cargo build --release
</code></pre>
<p>Then you can run CeresDB using the default configuration file provided in the codebase.</p>
<pre><code class="language-bash">./target/release/ceresdb-server --config ./docs/minimal.toml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventional-commit-guide"><a class="header" href="#conventional-commit-guide">Conventional Commit Guide</a></h1>
<p>This document describes how we use <a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commit</a> in our development.</p>
<h1 id="structure"><a class="header" href="#structure">Structure</a></h1>
<p>We would like to structure our commit message like this:</p>
<pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;
</code></pre>
<p>There are three parts. <code>type</code> is used to classify which kind of work this commit does. <code>scope</code> is an optional field that provides additional contextual information. And the last field is your <code>description</code> of this commit.</p>
<h1 id="type"><a class="header" href="#type">Type</a></h1>
<p>Here we list some common <code>type</code>s and their meanings.</p>
<ul>
<li><code>feat</code>: Implement a new feature.</li>
<li><code>fix</code>: Patch a bug.</li>
<li><code>docs</code>: Add document or comment.</li>
<li><code>build</code>: Change the build script or configuration.</li>
<li><code>style</code>: Style change (only). No logic involved.</li>
<li><code>refactor</code>: Refactor an existing module for performance, structure, or other reasons.</li>
<li><code>test</code>: Enhance test coverage or sqlness.</li>
<li><code>chore</code>: None of the above.</li>
</ul>
<h1 id="scope"><a class="header" href="#scope">Scope</a></h1>
<p>The <code>scope</code> is more flexible than <code>type</code>. And it may have different values under different <code>type</code>s.</p>
<p>For example, In a <code>feat</code> or <code>build</code> commit we may use the code module to define scope, like</p>
<pre><code>feat(cluster):
feat(server):

build(ci):
build(image):
</code></pre>
<p>And in <code>docs</code> or <code>refactor</code> commits the motivation is prefer to label the <code>scope</code>, like</p>
<pre><code>docs(comment):
docs(post):

refactor(perf):
refactor(usability):
</code></pre>
<p>But you don't need to add a scope every time. This isn't mandatory. It's just a way to help describe the commit.</p>
<h1 id="after-all"><a class="header" href="#after-all">After all</a></h1>
<p>There are many other rules or scenarios in <a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commit</a>'s website. We are still exploring a better and more friendly workflow. Please do let us know by <a href="https://github.com/CeresDB/ceresdb/issues/new/choose">open an issue</a> if you have any suggestions ❤️</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rationale-and-goals"><a class="header" href="#rationale-and-goals">Rationale and Goals</a></h1>
<p>As every Rust programmer knows, the language has many powerful features, and there are often
several patterns which can express the same idea. Also, as every professional programmer comes to
discover, code is almost always read far more than it is written.</p>
<p>Thus, we choose to use a consistent set of idioms throughout our code so that it is easier to read
and understand for both existing and new contributors.</p>
<h2 id="unsafe-and-platform-dependent-conditional-compilation"><a class="header" href="#unsafe-and-platform-dependent-conditional-compilation">Unsafe and Platform-Dependent conditional compilation</a></h2>
<h3 id="avoid-unsafe-rust"><a class="header" href="#avoid-unsafe-rust">Avoid <code>unsafe</code> Rust</a></h3>
<p>One of the main reasons to use Rust as an implementation language is its strong memory safety
guarantees; Almost all of these guarantees are voided by the use of <code>unsafe</code>. Thus, unless there is
an excellent reason and the use is discussed beforehand, it is unlikely CeresDB will accept patches
with <code>unsafe</code> code.</p>
<p>We may consider taking unsafe code given:</p>
<ul>
<li>performance benchmarks showing a <em>very</em> compelling improvement </li>
<li>a compelling explanation of why the same performance can not be achieved using <code>safe</code> code</li>
<li>tests showing how it works safely across threads</li>
</ul>
<h3 id="avoid-platform-specific-conditional-compilation-cfg"><a class="header" href="#avoid-platform-specific-conditional-compilation-cfg">Avoid platform-specific conditional compilation <code>cfg</code></a></h3>
<p>We hope that CeresDB is usable across many different platforms and Operating systems, which means we
put a high value on standard Rust.</p>
<p>While some performance critical code may require architecture specific instructions, (e.g.
<code>AVX512</code>) most of the code should not.</p>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<h3 id="all-errors-should-follow-the-snafu-crate-philosophy-and-use-snafu-functionality"><a class="header" href="#all-errors-should-follow-the-snafu-crate-philosophy-and-use-snafu-functionality">All errors should follow the <a href="https://docs.rs/snafu/0.6.10/snafu/guide/philosophy/index.html">SNAFU crate philosophy</a> and use SNAFU functionality</a></h3>
<p><em>Good</em>:</p>
<ul>
<li>Derives <code>Snafu</code> and <code>Debug</code> functionality</li>
<li>Has a useful, end-user-friendly display message</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Snafu, Debug)]
pub enum Error {
    #[snafu(display(r#&quot;Conversion needs at least one line of data&quot;#))]
    NeedsAtLeastOneLine,
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Bad</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    NeedsAtLeastOneLine,
    // ...
<span class="boring">}
</span></code></pre></pre>
<h3 id="use-the-ensure-macro-to-check-a-condition-and-return-an-error"><a class="header" href="#use-the-ensure-macro-to-check-a-condition-and-return-an-error">Use the <code>ensure!</code> macro to check a condition and return an error</a></h3>
<p><em>Good</em>:</p>
<ul>
<li>Reads more like an <code>assert!</code></li>
<li>Is more concise</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ensure!(!self.schema_sample.is_empty(), NeedsAtLeastOneLine);
<span class="boring">}
</span></code></pre></pre>
<p><em>Bad</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.schema_sample.is_empty() {
    return Err(Error::NeedsAtLeastOneLine {});
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="errors-should-be-defined-in-the-module-they-are-instantiated"><a class="header" href="#errors-should-be-defined-in-the-module-they-are-instantiated">Errors should be defined in the module they are instantiated</a></h3>
<p><em>Good</em>:</p>
<ul>
<li>Groups related error conditions together most closely with the code that produces them</li>
<li>Reduces the need to <code>match</code> on unrelated errors that would never happen</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display(&quot;Not implemented: {}&quot;, operation_name))]
    NotImplemented { operation_name: String }
}
// ...
ensure!(foo.is_implemented(), NotImplemented {
    operation_name: &quot;foo&quot;,
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Bad</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::errors::NotImplemented;
// ...
ensure!(foo.is_implemented(), NotImplemented {
    operation_name: &quot;foo&quot;,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="the-result-type-alias-should-be-defined-in-each-module"><a class="header" href="#the-result-type-alias-should-be-defined-in-each-module">The <code>Result</code> type alias should be defined in each module</a></h3>
<p><em>Good</em>:</p>
<ul>
<li>Reduces repetition</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Result&lt;T, E = Error&gt; = std::result::Result&lt;T, E&gt;;
...
fn foo() -&gt; Result&lt;bool&gt; { true }
<span class="boring">}
</span></code></pre></pre>
<p><em>Bad</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
fn foo() -&gt; Result&lt;bool, Error&gt; { true }
<span class="boring">}
</span></code></pre></pre>
<h3 id="err-variants-should-be-returned-with-fail"><a class="header" href="#err-variants-should-be-returned-with-fail"><code>Err</code> variants should be returned with <code>fail()</code></a></h3>
<p><em>Good</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return NotImplemented {
    operation_name: &quot;Parquet format conversion&quot;,
}.fail();
<span class="boring">}
</span></code></pre></pre>
<p><em>Bad</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return Err(Error::NotImplemented {
    operation_name: String::from(&quot;Parquet format conversion&quot;),
});
<span class="boring">}
</span></code></pre></pre>
<h3 id="use-context-to-wrap-underlying-errors-into-module-specific-errors"><a class="header" href="#use-context-to-wrap-underlying-errors-into-module-specific-errors">Use <code>context</code> to wrap underlying errors into module specific errors</a></h3>
<p><em>Good</em>:</p>
<ul>
<li>Reduces boilerplate</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>input_reader
    .read_to_string(&amp;mut buf)
    .context(UnableToReadInput {
        input_filename,
    })?;
<span class="boring">}
</span></code></pre></pre>
<p><em>Bad</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>input_reader
    .read_to_string(&amp;mut buf)
    .map_err(|e| Error::UnableToReadInput {
        name: String::from(input_filename),
        source: e,
    })?;
<span class="boring">}
</span></code></pre></pre>
<p><em>Hint for <code>Box&lt;dyn::std::error::Error&gt;</code> in Snafu</em>:</p>
<p>If your error contains a trait object (e.g. <code>Box&lt;dyn std::error::Error + Send + Sync&gt;</code>), in order
to use <code>context()</code> you need to wrap the error in a <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Snafu)]
pub enum Error {

    #[snafu(display(&quot;gRPC planner got error listing partition keys: {}&quot;, source))]
    ListingPartitions {
        source: Box&lt;dyn std::error::Error + Send + Sync&gt;,
    },
}

...

  // Wrap error in a box prior to calling context()
database
  .partition_keys()
  .await
  .map_err(|e| Box::new(e) as _)
  .context(ListingPartitions)?;
<span class="boring">}
</span></code></pre></pre>
<p>Note the <code>as _</code> in the <code>map_err</code> call. Without it, you may get an error such as:</p>
<pre><code class="language-console">error[E0271]: type mismatch resolving `&lt;ListingPartitions as IntoError&lt;influxrpc::Error&gt;&gt;::Source == Box&lt;&lt;D as Database&gt;::Error&gt;`
  --&gt; query/src/frontend/influxrpc.rs:63:14
   |
63 |             .context(ListingPartitions)?;
   |              ^^^^^^^ expected trait object `dyn snafu::Error`, found associated type
   |
   = note: expected struct `Box&lt;(dyn snafu::Error + Send + Sync + 'static)&gt;`
              found struct `Box&lt;&lt;D as Database&gt;::Error&gt;`
   = help: consider constraining the associated type `&lt;D as Database&gt;::Error` to `(dyn snafu::Error + Send + Sync + 'static)`
   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html
</code></pre>
<h3 id="each-error-cause-in-a-module-should-have-a-distinct-error-enum-variant"><a class="header" href="#each-error-cause-in-a-module-should-have-a-distinct-error-enum-variant">Each error cause in a module should have a distinct <code>Error</code> enum variant</a></h3>
<p>Specific error types are preferred over a generic error with a <code>message</code> or <code>kind</code> field.</p>
<p><em>Good</em>:</p>
<ul>
<li>Makes it easier to track down the offending code based on a specific failure</li>
<li>Reduces the size of the error enum (<code>String</code> is 3x 64-bit vs no space)</li>
<li>Makes it easier to remove vestigial errors</li>
<li>Is more concise</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display(&quot;Error writing remaining lines {}&quot;, source))]
    UnableToWriteGoodLines { source: IngestError },

    #[snafu(display(&quot;Error while closing the table writer {}&quot;, source))]
    UnableToCloseTableWriter { source: IngestError },
}

// ...

write_lines.context(UnableToWriteGoodLines)?;
close_writer.context(UnableToCloseTableWriter))?;
<span class="boring">}
</span></code></pre></pre>
<p><em>Bad</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    #[snafu(display(&quot;Error {}: {}&quot;, message, source))]
    WritingError {
        source: IngestError,
        message: String,
    },
}

write_lines.context(WritingError {
    message: String::from(&quot;Error while writing remaining lines&quot;),
})?;
close_writer.context(WritingError {
    message: String::from(&quot;Error while closing the table writer&quot;),
})?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<h3 id="dont-return-result-from-test-functions"><a class="header" href="#dont-return-result-from-test-functions">Don't return <code>Result</code> from test functions</a></h3>
<p>At the time of this writing, if you return <code>Result</code> from test functions to use <code>?</code> in the test
function body and an <code>Err</code> value is returned, the test failure message is not particularly helpful.
Therefore, prefer not having a return type for test functions and instead using <code>expect</code> or
<code>unwrap</code> in test function bodies.</p>
<p><em>Good</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn google_cloud() {
    let config = Config::new();
    let integration = ObjectStore::new_google_cloud_storage(GoogleCloudStorage::new(
        config.service_account,
        config.bucket,
    ));

    put_get_delete_list(&amp;integration).unwrap();
    list_with_delimiter(&amp;integration).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Bad</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type TestError = Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;;
type Result&lt;T, E = TestError&gt; = std::result::Result&lt;T, E&gt;;

#[test]
fn google_cloud() -&gt; Result&lt;()&gt; {
    let config = Config::new();
    let integration = ObjectStore::new_google_cloud_storage(GoogleCloudStorage::new(
        config.service_account,
        config.bucket,
    ));

    put_get_delete_list(&amp;integration)?;
    list_with_delimiter(&amp;integration)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="thanks"><a class="header" href="#thanks">Thanks</a></h2>
<p>Fork from <a href="https://github.com/influxdata/influxdb_iox/blob/main/docs/style_guide.md">influxdb_iox</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="roadmap"><a class="header" href="#roadmap">RoadMap</a></h2>
<h3 id="v010"><a class="header" href="#v010">v0.1.0</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Standalone version, local storage</li>
<li><input disabled="" type="checkbox" checked=""/>
Analytical storage format</li>
<li><input disabled="" type="checkbox" checked=""/>
Support SQL</li>
</ul>
<h3 id="v020"><a class="header" href="#v020">v0.2.0</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Distributed version supports static topology defined in config file.</li>
<li><input disabled="" type="checkbox" checked=""/>
The underlying storage supports Aliyun OSS.</li>
<li><input disabled="" type="checkbox" checked=""/>
WAL implementation based on <a href="https://github.com/oceanbase/oceanbase">OBKV</a>.</li>
</ul>
<h3 id="v030"><a class="header" href="#v030">v0.3.0</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Release multi-language clients, including Java, Rust and Python.</li>
<li><input disabled="" type="checkbox" checked=""/>
Static cluster mode with <code>CeresMeta</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Basic implementation of hybrid storage format.</li>
</ul>
<h3 id="v040-released"><a class="header" href="#v040-released">v0.4.0 (Released)</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Implement more sophisticated cluster solution that enhances reliability and scalability of CeresDB.</li>
<li><input disabled="" type="checkbox" checked=""/>
Set up nightly benchmark with TSBS.</li>
</ul>
<h3 id="v100-alpha"><a class="header" href="#v100-alpha">v1.0.0-alpha</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Implement Distributed WAL based on <code>Apache Kafka</code>.</li>
<li><input disabled="" type="checkbox"/>
Release Golang client.</li>
<li><input disabled="" type="checkbox"/>
Improve the query performance for traditional time series workloads.</li>
<li><input disabled="" type="checkbox"/>
Support dynamic migration of tables in cluster mode.</li>
</ul>
<h3 id="afterward"><a class="header" href="#afterward">Afterward</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Support Prometheus protocol.</li>
<li><input disabled="" type="checkbox"/>
Implement UDF framework which makes CeresDB more extensible.</li>
<li><input disabled="" type="checkbox"/>
Support more underlying storages for adaptivity. For example, the underlying storage could be a distributed file system.</li>
<li><input disabled="" type="checkbox"/>
Various tools that ease the use of CeresDB. For example, data import and export tools.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-ceresdbs-architecture"><a class="header" href="#introduction-to-ceresdbs-architecture">Introduction to CeresDB's Architecture</a></h1>
<h2 id="target-2"><a class="header" href="#target-2">Target</a></h2>
<ul>
<li>Provide the overview of CeresDB to the developers who want to know more about CeresDB but have no idea where to start.</li>
<li>Make a brief introduction to the important modules of CeresDB and the connections between these modules but details about their implementations are not be involved.</li>
</ul>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>CeresDB is a timeseries database. However, CeresDB's goal is to handle both timeseries and analytic workloads compared with the traditional ones, which usually have a poor performance in handling analytic workloads.</p>
<p>In the traditional timeseries database, the <code>Tag</code> columns (InfluxDB calls them <code>Tag</code> and Prometheus calls them <code>Label</code>) are normally indexed by generating an inverted index. However, it is found that the cardinality of <code>Tag</code> varies in different scenarios. And in some scenarios the cardinality of <code>Tag</code> is very high, and it takes a very high cost to store and retrieve the inverted index. On the other hand, it is observed that scanning+pruning often used by the analytical databases can do a good job to handle such these scenarios.</p>
<p>The basic design idea of CeresDB is to adopt a hybrid storage format and the corresponding query method for a better performance in processing both timeseries and analytic workloads.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code class="language-plaintext">┌──────────────────────────────────────────┐
│       RPC Layer (HTTP/gRPC/MySQL)        │
└──────────────────────────────────────────┘
┌──────────────────────────────────────────┐
│                 SQL Layer                │
│ ┌─────────────────┐  ┌─────────────────┐ │
│ │     Parser      │  │     Planner     │ │
│ └─────────────────┘  └─────────────────┘ │
└──────────────────────────────────────────┘
┌───────────────────┐  ┌───────────────────┐
│    Interpreter    │  │      Catalog      │
└───────────────────┘  └───────────────────┘
┌──────────────────────────────────────────┐
│               Query Engine               │
│ ┌─────────────────┐  ┌─────────────────┐ │
│ │    Optimizer    │  │    Executor     │ │
│ └─────────────────┘  └─────────────────┘ │
└──────────────────────────────────────────┘
┌──────────────────────────────────────────┐
│         Pluggable Table Engine           │
│  ┌────────────────────────────────────┐  │
│  │              Analytic              │  │
│  │┌────────────────┐┌────────────────┐│  │
│  ││      Wal       ││    Memtable    ││  │
│  │└────────────────┘└────────────────┘│  │
│  │┌────────────────┐┌────────────────┐│  │
│  ││     Flush      ││   Compaction   ││  │
│  │└────────────────┘└────────────────┘│  │
│  │┌────────────────┐┌────────────────┐│  │
│  ││    Manifest    ││  Object Store  ││  │
│  │└────────────────┘└────────────────┘│  │
│  └────────────────────────────────────┘  │
│  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │
│           Another Table Engine        │  │
│  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │
└──────────────────────────────────────────┘
</code></pre>
<p>The figure above shows the architecture of CeresDB stand-alone service and the details of some important modules will be described in the following part.</p>
<h3 id="rpc-layer"><a class="header" href="#rpc-layer">RPC Layer</a></h3>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/server</p>
<p>The current RPC supports multiple protocols including HTTP, gRPC, MySQL.</p>
<p>Basically, HTTP and MySQL are used to debug CeresDB, query manually and perform DDL operations (such as creating, deleting tables, etc.). And gRPC protocol can be regarded as a customized protocol for high-performance, which is suitable for massive reading and writing operations.</p>
<h3 id="sql-layer"><a class="header" href="#sql-layer">SQL Layer</a></h3>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/sql</p>
<p>SQL layer takes responsibilities for parsing sql and generating the plan.</p>
<p>Based on <a href="https://github.com/sqlparser-rs/sqlparser-rs">sqlparser</a> a sql dialect, which introduces some key concepts including <code>Tag</code> and <code>Timestamp</code>, is provided for processing timeseries data. And by utilizing <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> the planner can generate not only normal logical plans but also custom ones, such as plans for <code>PromQL</code>.</p>
<h3 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h3>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/interpreters</p>
<p>The <code>Interpreter</code> module encapsulates the SQL <code>CRUD</code> operations. Actually, a sql received by CeresDB will be parsed, converted into the query plan and then executed in some specific interpreter, such as <code>SelectInterpreter</code>, <code>InsertInterpreter</code> and etc.</p>
<h3 id="catalog"><a class="header" href="#catalog">Catalog</a></h3>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/catalog_impls</p>
<p><code>Catalog</code> is actually the module managing metadata and the levels of metadata adopted by CeresDB is similar to PostgreSQL: <code>Catalog &gt; Schema &gt; Table</code>, but they are only used as namespace.</p>
<p>At present, <code>Catalog</code> and <code>Schema</code> have two different kinds of implementation for stand-alone and distributed mode because some strategies to generate ids and ways to persist metadata differ in different mode.</p>
<h3 id="query-engine"><a class="header" href="#query-engine">Query Engine</a></h3>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/query_engine</p>
<p><code>Query Engine</code> is responsible for optimizing and executing query plan given a basic SQL plan provided by SQL layer and now such work is mainly delegated to <a href="https://github.com/apache/arrow-datafusion">DataFusion</a>.</p>
<p>In addition to the basic functions of SQL, CeresDB also defines some customized query protocols and optimization rules for some specific query plans by utilizing the extensibility provided by <a href="https://github.com/apache/arrow-datafusion">DataFusion</a>. For example, the implementation of <code>PromQL</code> is implemented in this way and read it if you are interested.</p>
<h3 id="pluggable-table-engine"><a class="header" href="#pluggable-table-engine">Pluggable Table Engine</a></h3>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/table_engine</p>
<p><code>Table Engine</code> is actually a storage engine for managing tables in CeresDB and the pluggability of <code>Table Engine</code> is a core design of CeresDB which matters in achieving our target (process both timeseries and analytic workloads well). CeresDB will have multiple kinds of <code>Table Engine</code> for different workloads and the most appropriate one should be chosen as the storage engine according to the workload pattern.</p>
<p>Now the requirements for a <code>Table Engine</code> are:</p>
<ul>
<li>Manage all the shared resources under the engine:
<ul>
<li>Memory</li>
<li>Storage</li>
<li>CPU</li>
</ul>
</li>
<li>Manage metadata of tables such as table schema and table options;</li>
<li>Provide <code>Table</code> instances which provides <code>read</code> and <code>write</code> methods;</li>
<li>Take responsibilities for creating, opening, dropping and closing <code>Table</code> instance;</li>
<li>....</li>
</ul>
<p>Actually the things that a <code>Table Engine</code> needs to process are a little complicated. And now in CeresDB only one <code>Table Engine</code> called <code>Analytic</code> is provided and does a good job in processing analytical workload, but it is not ready yet to handle the timeseries workload (we plan to enhance it for a better performance by adding some indexes which help handle timeseries workload).</p>
<p>The following part gives a description about details of <code>Analytic Table Engine</code>.</p>
<h4 id="wal"><a class="header" href="#wal">WAL</a></h4>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/wal</p>
<p>The model of CeresDB processing data is <code>WAL</code> + <code>MemTable</code> that the recent written data is written to <code>WAL</code> first and then to <code>MemTable</code> and after a certain amount of data in <code>MemTable</code> is accumulated, the data will be organized in a query-friendly form to persistent devices.</p>
<p>Now two implementations of <code>WAL</code> are provided for stand-alone and distributed mode:</p>
<ul>
<li>For stand-alone mode, <code>WAL</code> is based on <code>RocksDB</code> and data is persisted on the local disk.</li>
<li>For distributed mode, <code>WAL</code> is required as a distributed component and to be responsible for reliability of the newly written data, so now we provide an implementation based on <a href="https://github.com/oceanbase/oceanbase">OceanBase</a> and in our roadmap a more lightweight implementation will be provided.</li>
</ul>
<p>Besides, <code>WAL</code>'s trait definition tells that <code>WAL</code> has the concept of <code>Region</code> and actually each table is assigned to a <code>Region</code> so that the isolation between tables is gained and such an isolation provides convenience for some operations on table's level (such as different <code>TTL</code>s for different tables).</p>
<h4 id="memtable"><a class="header" href="#memtable">MemTable</a></h4>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/analytic_engine/src/memtable</p>
<p><code>Memtable</code> is used to store the newly written data and after a certain amount of data is accumulated, CeresDB organizes the data in <code>MemTable</code> into a query-friendly storage format (<code>SST</code>) and stores it to the persistent device. <code>MemTable</code> is readable before it gets persisted (flushed).</p>
<p>The current implementation of <code>MemTable</code> is based on <a href="https://github.com/tikv/agatedb/blob/8510bff2bfde5b766c3f83cf81c00141967d48a4/skiplist">agatedb's skiplist</a>. It allows concurrent reads and writes and can control memory usage based on <a href="https://github.com/CeresDB/ceresdb/tree/main/components/skiplist">Arena</a>.</p>
<h4 id="flush"><a class="header" href="#flush">Flush</a></h4>
<p>module path: https://github.com/CeresDB/ceresdb/blob/main/analytic_engine/src/instance/flush_compaction.rs</p>
<p>What <code>Flush</code> does is that when the memory usage of <code>MemTable</code> reaches the threshold, some <code>MemTables</code> are selected for flushing into query-friendly <code>SST</code>s saved on persistent device.</p>
<p>During the flushing procedure, the data will be divided by a certain time range (which is configured by table option <code>Segment Duration</code>), and no <code>SST</code> will span the <code>Segment Duration</code>. Actually this is also a common operation in most timeseries databases which organizes data in the time dimension to speed up subsequent time-related operations, such as querying data over a time range and assisting purge data outside the <code>TTL</code>.</p>
<p>At present, the control process of <code>Flush</code> is a little complicated, so the details will be explained in another document.</p>
<h4 id="compaction"><a class="header" href="#compaction">Compaction</a></h4>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/analytic_engine/src/compaction</p>
<p>The data of <code>MemTable</code> is flushed as <code>SST</code>s, but the file size of recently flushed <code>SST</code> may be very small. And too small or too many <code>SST</code>s lead to the poor query performance. Therefore, <code>Compaction</code> is then introduced to rearrange the <code>SST</code>s so that the multiple smaller <code>SST</code> files can be compacted into a larger <code>SST</code> file.</p>
<p>The detailed strategy of <code>Compaction</code> will also be described with <code>Flush</code> in subsequent documents.</p>
<h4 id="manifest"><a class="header" href="#manifest">Manifest</a></h4>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/analytic_engine/src/meta</p>
<p><code>Manifest</code> takes responsibilities for managing tables' metadata of <code>Analytic Engine</code> including:</p>
<ul>
<li>Table schema and table options;</li>
<li>The sequence number where the newest flush finishes;</li>
<li>The information of <code>SST</code>, such as <code>SST</code> path.</li>
</ul>
<p>Now the <code>Manifest</code> is based on <code>WAL</code> (this is a different instance from the <code>WAL</code> mentioned above for newly written data) and in order to avoid infinite expansion of metadata (actually every <code>Flush</code> leads to an update on sst information), <code>Snapshot</code> is also introduced to clean up the history of metadata updates.</p>
<h4 id="object-store"><a class="header" href="#object-store">Object Store</a></h4>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/components/object_store</p>
<p>The <code>SST</code> generated by <code>Flush</code> needs to be persisted and the abstraction of the persistent storage device is <code>ObjectStore</code> including multiple implementations:</p>
<ul>
<li>Based on local file system;</li>
<li>Based on <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a>.</li>
</ul>
<p>The distributed architecture of CeresDB separates storage and computing, which requires <code>Object Store</code> needs to be a highly available and reliable service independent of CeresDB. Therefore, storage systems like <a href="https://aws.amazon.com/s3/">Amazon S3</a>, <a href="https://www.alibabacloud.com/product/object-storage-service">Alibaba Cloud OSS</a> is a good choice and in the future implementations on storage systems of some other cloud service providers is planned to provide.</p>
<h4 id="sst"><a class="header" href="#sst">SST</a></h4>
<p>module path: https://github.com/CeresDB/ceresdb/tree/main/analytic_engine/src/sst</p>
<p>Both <code>Flush</code> and <code>Compaction</code> involves <code>SST</code> and in the codebase <code>SST</code> itself is actually an abstraction that can have multiple specific implementations. The current implementation is based on <a href="https://parquet.apache.org/">Parquet</a>, which is a column-oriented data file format designed for efficient data storage and retrieval.</p>
<p>The format of <code>SST</code> is very critical for retrieving data and is also the most important part to perform well in handling both timeseries and analytic workloads. At present, our <a href="https://parquet.apache.org/">Parquet</a>-based implementation is good at processing analytic workload but is poor at processing timeseries workload. In our roadmap, we will explore more storage formats in order to achieve a good performance in both workloads.</p>
<h4 id="space"><a class="header" href="#space">Space</a></h4>
<p>module path: https://github.com/CeresDB/ceresdb/blob/main/analytic_engine/src/space.rs</p>
<p>In <code>Analytic Engine</code>, there is a concept called <code>space</code> and here is an explanation for it to resolve some ambiguities when read source code. Actually <code>Analytic Engine</code> does not have the concept of <code>catalog</code> and <code>schema</code> and only provides two levels of relationship: <code>space</code> and <code>table</code>. And in the implementation, the <code>schema id</code> (which should be unique across all <code>catalog</code>s) on the upper layer is actually mapped to <code>space id</code>.</p>
<p>The <code>space</code> in <code>Analytic Engine</code> serves mainly for isolation of resources for different tenants, such as the usage of memory.</p>
<h2 id="critical-path"><a class="header" href="#critical-path">Critical Path</a></h2>
<p>After a brief introduction to some important modules of CeresDB, we will give a description for some critical paths in code, hoping to provide interested developers with a guide for reading the code.</p>
<h3 id="query"><a class="header" href="#query">Query</a></h3>
<pre><code class="language-plaintext">┌───────┐      ┌───────┐      ┌───────┐
│       │──1──▶│       │──2──▶│       │
│Server │      │  SQL  │      │Catalog│
│       │◀─10──│       │◀─3───│       │
└───────┘      └───────┘      └───────┘
                │    ▲
               4│   9│
                │    │
                ▼    │
┌─────────────────────────────────────┐
│                                     │
│             Interpreter             │
│                                     │
└─────────────────────────────────────┘
                           │    ▲
                          5│   8│
                           │    │
                           ▼    │
                   ┌──────────────────┐
                   │                  │
                   │   Query Engine   │
                   │                  │
                   └──────────────────┘
                           │    ▲
                          6│   7│
                           │    │
                           ▼    │
 ┌─────────────────────────────────────┐
 │                                     │
 │            Table Engine             │
 │                                     │
 └─────────────────────────────────────┘
</code></pre>
<p>Take <code>SELECT</code> SQL as an example. The figure above shows the query procedure and the numbers in it indicates the order of calling between the modules.</p>
<p>Here are the details:</p>
<ul>
<li>Server module chooses a proper rpc module (it may be HTTP, gRPC or mysql) to process the requests according the protocol used by the requests;</li>
<li>Parse SQL in the request by the parser;</li>
<li>With the parsed sql and the catalog/schema module, <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> can generate the logical plan;</li>
<li>With the logical plan, the corresponding <code>Interpreter</code> is created and logical plan will be executed by it;</li>
<li>For the logical plan of normal <code>Select</code> SQL, it will be executed through <code>SelectInterpreter</code>;</li>
<li>In the <code>SelectInterpreter</code> the specific query logic is executed by the <code>Query Engine</code>:
<ul>
<li>Optimize the logical plan;</li>
<li>Generate the physical plan;</li>
<li>Optimize the physical plan;</li>
<li>Execute the physical plan;</li>
</ul>
</li>
<li>The execution of physical plan involves <code>Analytic Engine</code>:
<ul>
<li>Data is obtained by <code>read</code> method of <code>Table</code> instance provided by <code>Analytic Engine</code>;</li>
<li>The source of the table data is <code>SST</code> and <code>Memtable</code>, and the data can be filtered by the pushed down predicates;</li>
<li>After retrieving the table data, <code>Query Engine</code> will complete the specific computation and generate the final results;</li>
</ul>
</li>
<li><code>SelectInterpreter</code> gets the results and feeds them to the protocol module;</li>
<li>After the protocol layer converts the results, the server module responds to the client with them.</li>
</ul>
<h3 id="write"><a class="header" href="#write">Write</a></h3>
<pre><code class="language-plaintext">┌───────┐      ┌───────┐      ┌───────┐
│       │──1──▶│       │──2──▶│       │
│Server │      │  SQL  │      │Catalog│
│       │◀─8───│       │◀─3───│       │
└───────┘      └───────┘      └───────┘
                │    ▲
               4│   7│
                │    │
                ▼    │
┌─────────────────────────────────────┐
│                                     │
│             Interpreter             │
│                                     │
└─────────────────────────────────────┘
      │    ▲
      │    │
      │    │
      │    │
      │    │       ┌──────────────────┐
      │    │       │                  │
     5│   6│       │   Query Engine   │
      │    │       │                  │
      │    │       └──────────────────┘
      │    │
      │    │
      │    │
      ▼    │
 ┌─────────────────────────────────────┐
 │                                     │
 │            Table Engine             │
 │                                     │
 └─────────────────────────────────────┘
</code></pre>
<p>Take <code>INSERT</code> SQL as an example. The figure above shows the query procedure and the numbers in it indicates the order of calling between the modules.</p>
<p>Here are the details:</p>
<ul>
<li>Server module chooses a proper rpc module (it may be HTTP, gRPC or mysql) to process the requests according the protocol used by the requests;</li>
<li>Parse SQL in the request by the parser;</li>
<li>With the parsed sql and the catalog/schema module, <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> can generate the logical plan;</li>
<li>With the logical plan, the corresponding <code>Interpreter</code> is created and logical plan will be executed by it;</li>
<li>For the logical plan of normal <code>INSERT</code> SQL, it will be executed through <code>InsertInterpreter</code>;</li>
<li>In the <code>InsertInterpreter</code>, <code>write</code> method of <code>Table</code> provided <code>Analytic Engine</code> is called:
<ul>
<li>Write the data into <code>WAL</code> first;</li>
<li>Write the data into <code>MemTable</code> then;</li>
</ul>
</li>
<li>Before writing to <code>MemTable</code>, the memory usage will be checked. If the memory usage is too high, the flush process will be triggered:
<ul>
<li>Persist some old MemTables as <code>SST</code>s;</li>
<li>Delete the corresponding <code>WAL</code> entries;</li>
<li>Updates the manifest for the new <code>SST</code>s and the sequence number of <code>WAL</code>;</li>
</ul>
</li>
<li>Server module responds to the client with the execution result.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-1"><a class="header" href="#query-1">Query</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wal-1"><a class="header" href="#wal-1">Wal</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-partitioning"><a class="header" href="#table-partitioning">Table Partitioning</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
